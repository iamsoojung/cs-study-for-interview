## 📖 학습 주제

- **주제**: 배열과 연결 리스트
- **날짜**: 2024-10-27

---

## 📌 학습 내용 요약

### 🔗 배열

- **배열 (Array)** : 일정한 메모리 공간을 차지하는 여러 요소들이 `순차적으로 나열`된 자료구조
  - **인덱스** : 각 요소의 0부터 시작하는 고유한 순서 번호

  - 각 연산의 시간 복잡도
    - 인덱스가 주어졌을 때 특정 요소 **접근** 연산 : O(1)
    - 인덱스가 주어졌을 때 특정 요소 **수정** 연산 : O(1)
    - 서로 다른 N개의 데이터에서 특정 데이터 **검색** 연산 : O(N)
    - 특정 인덱스의 요소 **추가** 연산 : O(N)
    - 특정 인덱스의 요소 **삭제** 연산 : O(N)

- **정적 배열**
  - 프로그램을 실행하기 전 크기가 고정되어 있는 배열
  - 프로그램 도중 변경 X

- **동적 배열**
  - 실행 과정에서 크기가 변할 수 있는 배열
  - 배열의 크기를 알기 어려운 경우 or 유연하게 요소 개수를 조정해야 하는 경우 사용
    - *동적 배열을 벡터(vector)로 구현한 프로그래밍 언어도 존재*

### 🔗 연결 리스트

- **연결 리스트 (Linked List)** : `노드의 모음`으로 구성된 자료구조
  - **노드** : 저장하고자 하는 데이터 & 다음 노드의 위치 정보 포함하는 연결 리스트의 구성 단위
  - `head`부터 시작하여 `tail`까지 한쪽 방향으로 꼬리 무는 형태로 구성
  - 모든 노드는 반드시 메모리 내에 순차적으로 저장되어 있을 필요 X
    -> 연속된 데이터를 불연속적으로 저장할 때 유용

  - 각 연산의 시간 복잡도
    - 특정 요소 **접근** 연산 : O(N) 👉🏻 첫 노드부터 순차적으로 접근하므로.
    - 중간에 요소 추가/삭제 연산 : O(1) 👉🏻 재정렬이 불필요하므로.

- **싱글 연결 리스트** : 각 노드가 `다음 노드에 대한 참조`만을 가지는 가장 기본적인 연결 리스트
    - 구성 요소
        - `데이터`: 노드에 저장되는 실제 값
        - `next 포인터`: 다음 노드를 가리키는 참조
        - 마지막 노드의 next는 `null`을 가리킴

    - 특징
        - **장점**
            - 구현이 간단하고 메모리 사용이 적음
            - 노드의 삽입과 삭제가 O(1)로 효율적
        - **단점**
            - 이전 노드로의 접근이 불가능
            - 역방향 순회가 불가능

    - 활용
        - 스택 구현
        - 간단한 리스트 관리
        - 메모리가 제한적인 환경

    ![image](https://github.com/user-attachments/assets/ee4d84d5-b26f-44c5-ac40-8ad5b8a92318)

- **이중 연결 리스트** : 각 노드가 `이전 노드와 다음 노드에 대한 참조` 모두를 가지는 연결 리스트
    - 구성 요소
        - `데이터`: 노드에 저장되는 실제 값
        - `next 포인터`: 다음 노드를 가리키는 참조
        - `prev 포인터`: 이전 노드를 가리키는 참조

    - 특징
        - **장점**
            - 양방향 순회 가능
            - 노드 삭제 시 이전 노드를 찾을 필요 없음
            - 리스트의 양 끝에서의 작업이 효율적
        - **단점**
            - 추가 메모리 공간 필요 (prev 포인터)
            - 구현이 복잡함

    - 활용
        - 웹 브라우저의 앞으로/뒤로 가기
        - LRU 캐시 구현
        - 복잡한 데이터 구조의 기반
    
    ![image](https://github.com/user-attachments/assets/0dcc2ad8-c630-4e08-af11-a1ceeca77274)

- **원형 연결 리스트** : 마지막 노드가 첫 번째 노드를 가리켜 `원형`을 이루는 연결 리스트
    - 구현 방식
        - 단방향 원형 리스트: 마지막 노드의 next가 head를 가리킴
        - 양방향 원형 리스트: 마지막 노드의 next는 head를, head의 prev는 마지막 노드를 가리킴

    - 특징
        - **장점**
            - 리스트의 끝에 도달했을 때 다시 처음부터 순회 가능
            - 원형 큐 등의 구현에 적합
            - 메모리를 효율적으로 사용 가능
        - **단점**
        - 무한 루프 발생 가능성
        - 구현이 복잡할 수 있음

    - 활용
        - 운영체제의 작업 스케줄링
        - 멀티플레이어 게임의 순서 관리
        - 버퍼 관리
    
    ![image](https://github.com/user-attachments/assets/9f783684-0768-40ac-a6f9-36945ef817c5)

---

## 📈 추가 학습 필요

- Java Collections Framework
  - ArrayList
    - **장점**: 
      - 인덱스를 통한 빠른 접근(O(1))
      - 메모리 사용 효율적
    - **단점**: 
      - 요소 추가 및 삭제 시 O(N) 시간 소요

  - LinkedList
    - **장점**: 
      - 요소 추가 및 삭제 시 O(1)
      - 메모리 동적 할당
    - **단점**: 
      - 인덱스 접근 시 O(N) 시간 소요

  - 사용 상황
    - **데이터 크기가 자주 변하는 경우**: LinkedList가 유리
    - **데이터에 대한 빠른 인덱스 접근이 필요한 경우**: ArrayList가 유리

- Concurrent Collections
  : 멀티스레딩 환경에서 안전하게 사용할 수 있는 컬렉션을 제공하는 Java의 컬렉션
  - **특징**
    - **스레드 안전성**: 여러 스레드가 동시에 데이터에 접근하거나 수정할 때 발생할 수 있는 경쟁 상태를 방지
    - **Lock-free 구조**: 일반적으로 락을 사용하지 않고도 스레드 간의 안전성을 보장하여 성능 저하를 최소화
  - **주요 클래스**
    - **CopyOnWriteArrayList**: 읽기 작업이 빈번하고 쓰기 작업이 드문 경우에 적합. 쓰기 작업 시 복사본을 만들어 안전하게 업데이트
    - **ConcurrentHashMap**: 멀티스레드 환경에서의 해시맵. 여러 스레드가 동시에 읽기 및 쓰기 가능
    - **BlockingQueue**: 생산자-소비자 패턴을 구현하는 데 유용한 큐로, 작업이 없을 경우 스레드가 블록됨
  - **사용 예시**
    ```java
    List<String> threadSafeList = new CopyOnWriteArrayList<>();
    ```

- Streams API
  : Java 8에서 도입된 기능으로, 컬렉션 및 배열과 같은 데이터 소스를 함수형 프로그래밍 스타일로 처리할 수 있는 API
  - **특징**
    - **지연 실행**: 데이터가 필요할 때까지 계산을 연기
    - **파이프라인 처리**: 데이터 처리 과정을 여러 단계로 나누어 수행
    - **병렬 처리 지원**: 간단한 방법으로 멀티코어 프로세서의 성능을 활용
  - **주요 메서드**
    - **filter**: 조건에 맞는 요소만 추출
    - **map**: 각 요소를 변환
    - **reduce**: 요소들을 합치거나 집계
    - **collect**: 최종 결과를 컬렉션으로 수집
  - **사용 예시**
    ```java
    List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
    List<String> filteredNames = names.stream()
        .filter(name -> name.startsWith("A"))
        .collect(Collectors.toList());
    ```
  - **중요성**
    - 코드의 가독성을 높이고, 불변성을 유지하여 오류를 줄이는 데 기여
    - 데이터 변환과 처리를 간결하고 명확하게 표현할 수 있어, 코드 작성 및 유지보수를 용이하게 함


---

## 💡 참고 자료

- https://hyeinisfree.tistory.com/64